"""Validator for LTI requests."""
import logging
import time

from django.conf import settings
from django.core.cache import cache

from oauthlib.oauth1 import RequestValidator

from marsha.core.defaults import LTI_REPLAY_PROTECTION_CACHE
from marsha.core.models import LTIPassport


logger = logging.getLogger(__name__)


class LTIRequestValidator(RequestValidator):
    """
    This validator implements the RequestValidator from the oauthlib, but only with methods
    required for an LTI launch request.
    """

    @property
    def enforce_ssl(self):
        """
        Returns:
            bool: True if SSL is mandatory, False otherwise
        """
        return False

    @property
    def nonce_length(self):
        """
        Returns:
            tuple: A tuple containing the min and max length of a nonce
        """
        return 5, 50

    @property
    def dummy_client(self):
        """Dummy client used when an invalid client key is supplied.

        Returns:
            string: The dummy client key string.
        """
        return "dummy_client_key_123456"

    def get_client_secret(self, client_key, request):
        """Retrieves the client secret associated with the client key.

        If an unknown client_key is given, it returns a valid dummy secret in
        order to avoid timing attacks.

        This method must allow the use of a dummy client_key value.
        Fetching the secret using the dummy key must take the same amount of
        time as fetching a secret for a valid client::

        Args:
            client_key: The client/consumer key.
            request: The calling request.
        """

        try:
            passport = LTIPassport.objects.get(
                oauth_consumer_key=client_key, is_enabled=True
            )
            return passport.shared_secret
        except LTIPassport.DoesNotExist:
            return "dummy_client_sec_123456"

    def check_client_key(self, client_key):
        if settings.DEBUG:
            # Allow the use of simple mnemonic keys in debug mode
            # such as the ones generated by load_development_datasets
            return True
        return super().check_client_key(client_key)

    def validate_client_key(self, client_key, request):
        """Validates that supplied client key is a registered and valid client.

        Args:
            client_key: The client/consumer key.
            request: The calling request

        Returns:
            bool: True if the client key is registered and valid
        """
        return LTIPassport.objects.filter(
            oauth_consumer_key=client_key, is_enabled=True
        ).exists()

    # pylint: disable=too-many-arguments
    def validate_timestamp_and_nonce(
        self,
        client_key: str,
        timestamp: str,
        nonce: str,
        request,
        request_token=None,
        access_token=None,
    ):
        """Validates that the nonce has not been used before

        Per `Section 3.3`_ of the OAuth 1.0 spec.

        "A nonce is a random string, uniquely generated by the client to allow
        the server to verify that a request has never been made before and
        helps prevent replay attacks when requests are made over a non-secure
        channel.  The nonce value MUST be unique across all requests with the
        same timestamp, client credentials, and token combinations."

        .. _`Section 3.3`: https://tools.ietf.org/html/rfc5849#section-3.3

        One of the first validation checks that will be made is for the validity
        of the nonce and timestamp, which are associated with a client key and
        possibly a token. If invalid then immediately fail the request
        by returning False. If the nonce/timestamp pair has been used before and
        you may just have detected a replay attack. Therefore, it is an essential
        part of OAuth security that you not allow nonce/timestamp reuse.
        Note that this validation check is done before checking the validity of
        the client and token.::

        Args:
            client_key: The client/consumer key.
            timestamp: The ``oauth_timestamp`` request parameter.
            nonce: The ``oauth_nonce`` request parameter.
            request: The calling request
            request_token: Request token string, if any.
            access_token: Access token string, if any.

        Returns:
            bool: True if the timestamp and nonce has not been used before
        """

        cache_timeout = settings.LTI_REPLAY_PROTECTION_CACHE_DURATION
        # Disallow usage of timestamp older than cache_timeout
        request_timestamp = int(timestamp)
        if request_timestamp < int(time.time()) - cache_timeout:
            logger.debug(
                "Timestamp is too old (ts = %s, consumer_key = %s, nonce = %s)",
                timestamp,
                client_key,
                nonce,
            )
            return False

        key = f"{LTI_REPLAY_PROTECTION_CACHE}:{client_key:s}:{timestamp:s}:{nonce:s}"

        if not cache.add(key, "1", cache_timeout):
            logger.warning(
                "Replayed timestamp/nonce detected (ts = %s, consumer_key = %s, nonce = %s)",
                timestamp,
                client_key,
                nonce,
            )
            return False

        logger.debug(
            "Timestamp and nonce valid (ts = %s, consumer_key = %s, nonce = %s)",
            timestamp,
            client_key,
            nonce,
        )
        return True
